#!/usr/bin/env python
import sys
import os
import re
import string
sys.path[:0] = '../../tools/python'
from fortran import OrderedDict

#headername = 'GUD_TRAITS.h'
#readername = 'gud_readtraits.F'

types = {}

def gettype(rhs):
    if rhs.strip().lower() in types:
        tp = types[rhs.strip().lower()]
    elif rhs[0] == '.' and rhs[1] not in string.digits:
        tp = 'LOGICAL'
    elif rhs[0] in '"' + "'":
        assert rhs[-1] == rhs[0]
        l = len(rhs) - 2
        tp = 'CHARACTER*{0}'.format(l)
    else:
        try:
            int(rhs)
        except ValueError:
            tp = '_RL'
        else:
            tp = 'INTEGER'
    return tp

typemap = dict(integer='i', _rl='r', logical='l', character='c')
tpprere = re.compile(r'[^a-zA-Z_0-9].*$')

def typeclass(tp):
    pre = tpprere.sub('', tp.lower())
    return typemap[pre]


#try:
#    fname,headername,readername = sys.argv[1:]
#except ValueError:
#    fname,headername,initname,readername = sys.argv[1:]
#else:
#    initname = None

secre = re.compile(r' *&([a-zA-Z_][a-zA-Z0-9_]*)? *$')
prere = re.compile(r' *([a-zA-Z_][a-zA-Z0-9_*]*: )(.*)$')
decre = re.compile(r' *([a-zA-Z_][a-zA-Z0-9_*]* )? *([a-zA-Z_][a-zA-Z0-9_]*) *(\([^)=]*\))? *$')
assre = re.compile(r' *([a-zA-Z_][a-zA-Z0-9_*]* )? *([a-zA-Z_][a-zA-Z0-9_]*) *(\([^)=]*\))? *= *(.*) *$')
expre = re.compile(r'\b([0-9]+\.(?![0-9])|\.?[0-9]+) *[dDeE] *([+-]?[0-9]+)(?! *[_dDeE0-9])')
fltre = re.compile(r'\b([0-9]+\.(?![0-9])|\.[0-9]+)(?! *[_dDeE0-9])')
dirre = re.compile(r'#')

dimre = re.compile(r' *DIMENSION *\((.*)\) *$')

args = sys.argv[1:]

sec = ''
dim = ()
secs = OrderedDict()
codes = OrderedDict()
heads = OrderedDict()
foots = OrderedDict()
codes[sec] = []
heads[sec] = []
foots[sec] = []
head = []
with len(args) and open(args[0]) or sys.stdin as f:
    headername = f.readline().strip()
    initname = f.readline().strip()
    readername = f.readline().strip()
    if len(readername) == 0:
        readername = initname
        initname = None
    else:
        tmp = f.readline().strip()
        assert len(tmp) == 0

    for iline,line in enumerate(f):
        try:
            m = secre.match(line)
            if m:
                sec = m.group(1)
                if sec is not None:
                    sec = sec.lower()
                    secs[sec] = OrderedDict()
                    codes[sec] = []
                    heads[sec] = None
                    foots[sec] = []
                    head = []
                continue

            m = dirre.match(line)
            if m:
                head.append(line)
                foots[sec].append(line)
            elif len(line.strip()) and line[0] != '!':
                if heads[sec] is None:
                    heads[sec] = head
                head = []
                foots[sec] = []

            m = dimre.match(line)
            if m:
                dim = m.group(1)
                continue

            m = prere.match(line)
            if m:
                pre,line = m.groups()
                pre = pre.strip()
                assert pre in ['LOCAL:', 'CODE:']
                if pre == 'LOCAL:' and '=' not in line:
                    mm = decre.match(line)
                    tp,name,args = mm.groups()
                    tp = tp.strip()
                    name = name.strip()
                    lname = name.lower()
                    mysec = sec == 'dependent' and 'locals_read' or 'locals'
                    sys.stderr.write('{0} {1}\n'.format(mysec, name))
                    secs.setdefault(mysec, OrderedDict())[lname] = (name,tp,args,dim,'')
                    continue
            else:
                pre = ''

            if pre != 'CODE:':
                m = assre.match(line)
                if m:
                    tp,name,args,rhs = m.groups()
                    lname = name.lower()
                    if '!' in rhs:
                        val,comm = string.split(rhs, '!', maxsplit=1)
                    else:
                        val = rhs
                    if tp is None:
                        tp = gettype(val)
                    else:
                        line = '{0}{1} = {2}'.format(name, args or '', rhs)
                    mysec = pre == 'LOCAL:' and 'locals' or sec
                    if mysec != sec:
                        sys.stderr.write('{0} {1}\n'.format(mysec, name))
                    secs[mysec][lname] = (name,tp,args,dim,rhs)
                    if mysec in ['parameters']:
                        types[lname] = tp

            codes[sec].append(line.rstrip())
        except:
            sys.stderr.write('Error parsing line {0}: {1}'.format(iline, line))
            raise


def writedecls(f, sec):
    for lname,(name,tp,args,dim,rhs) in sec.items():
        if lname not in declared:
            if args is not None:
                narg = len(args.split(','))
                diml = dim.split(',')[:narg]
                dims = '({0})'.format(','.join(diml))
            else:
                dims = ''
            f.write('      {0} {1}{2}\n'.format(tp, name, dims))
            declared[lname] = True

declared = {}

sys.stderr.write(headername + '\n')
with open(headername, 'w') as f:
    f.write('C$Header$\n')
    f.write('C$Name$\n')
    f.write('\n')
    f.write('C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n')
    f.write('C!!!!!!!!!!!!!! AUTOGENERATED FILE -- WILL BE OVERWRITTEN !!!!!!!!!!!!!!\n')
    f.write('C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n')
    f.write('\n')
    f.write('#ifdef ALLOW_GUD\n')
    f.write('\n')
    for secname, sec in secs.items():
        if secname not in ['locals', 'locals_read']:
            if heads[secname]:
                f.write(''.join(heads[secname]))
            allvrs = []
            for tpcls in 'lcir':
                vrs = [ name for lname,(name,tp,args,dim,rhs) in sec.items() if lname not in declared
                             and typeclass(tp) == tpcls ]
                if len(vrs):
                    if secname not in ['parameters']:
                        f.write(',\n     &    '.join(['      COMMON/{0}_{1}/\n     &    {2}'.format(secname, tpcls, vrs[0])] +
                                               vrs[1:]) + '\n')
                    allvrs.extend(vrs)

            if len(allvrs):
                writedecls(f, sec)

            if foots[secname]:
                f.write(''.join(foots[secname]))

            f.write('\n')

        if secname == 'parameters':
            for line in codes[secname]:
                line = line.rstrip()
                if '!' in line:
                    ind = line.index('!')
                    comment = '  ' + line[ind:]
                    line = line[:ind]
                else:
                    comment = ''
                line = fltre.sub(r'\1 _d 0', line)
                line = expre.sub(r'\1 _d \2', line)
                if line.lstrip().startswith('#'):
                    f.write(line + comment + '\n')
                elif '=' in line:
                    f.write('      PARAMETER({0}){1}\n'.format(line.strip(), comment))
                elif len(line.strip()) == 0:
                    f.write('\n')
                else:
                    f.write('!{0}'.format(line))
            f.write('\n')

    f.write('#endif /* ALLOW_GUD */\n')
    f.write('\n')

if initname is not None:
    sys.stderr.write(initname + '\n')
    with open(initname, 'w') as f:
        dr,name = os.path.split(initname)
        base,ext = os.path.splitext(name)
        f.write('C$Header$\n')
        f.write('C$Name$\n')
        f.write('\n')
        f.write('C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n')
        f.write('C!!!!!!!!!!!!!! AUTOGENERATED FILE -- WILL BE OVERWRITTEN !!!!!!!!!!!!!!\n')
        f.write('C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n')
        f.write('\n')
        f.write('#include "GUD_OPTIONS.h"\n')
        f.write('\n')
        f.write('      SUBROUTINE {0}(myThid)\n'.format(base.upper()))
        f.write('      IMPLICIT NONE\n')
        comments = []
        for code in codes['']:
            if code.lstrip().startswith('!') or len(code) == 0:
                comments.append(code + '\n')
            else:
                for comment in comments:
                    f.write(comment)
                comments = []
                f.write(code + '\n')

        f.write('#include "{0}"\n'.format(headername))
        f.write('\n')
        f.write('      INTEGER myThid\n')
        f.write('\n')
        f.write('#ifdef ALLOW_GUD\n')
        f.write('\n')

        for secname, sec in secs.items():
            if secname in ['locals']:
                writedecls(f, sec)
                f.write('\n')

        f.write('      _BEGIN_MASTER(myThid)\n')

        for comment in comments:
            f.write(comment)

        for secname, sec in secs.items():
            if secname not in ['parameters', 'dependent', 'locals_read']:
                f.write('C     {0}\n'.format(secname))
        #        for lname,(name,tp,args,dim,rhs) in sec.items():
        #            rhs = fltre.sub(r'\1 _d 0', rhs)
        #            rhs = expre.sub(r'\1 _d \2', rhs)
        #            f.write('      {0}{1}= {2},\n'.format(name, args, rhs))
        #        f.write('\n')
                pad = 0
                while len(codes[secname]) and len(codes[secname][-1]) == 0:
                    pad += 1
                    codes[secname][-1:] = []

                for line in codes[secname]:
                    line = line.rstrip()
                    if '!' in line:
                        ind = line.index('!')
                        comment = line[ind:]
                        line = line[:ind]
                    else:
                        comment = ''
                    line = fltre.sub(r'\1 _d 0', line)
                    line = expre.sub(r'\1 _d \2', line)
                    try:
                        indent = line.index('=') + 2
                    except ValueError:
                        indent = 2
                    if line.lstrip().startswith('#'):
                        f.write(line + comment + '\n')
                    elif len(line) == 0:
                        f.write(comment + '\n')
                    elif line not in ['/', '&']:
                        pre = '      '
                        mx = 72
                        while len(line) > mx-len(pre):
                            i = min(mx-len(pre), len(line)) - 1
                            while i and line[i] in string.ascii_letters + string.digits + '_':
                                i -= 1
                            f.write('{0}{1}\n'.format(pre, line[:i+1].rstrip()))
                            line = line[i+1:]
                            pre = '     &' + indent*' '
                        line = line + comment
                        f.write('{0}{1}\n'.format(len(line) and pre or '', line))

        f.write('      _END_MASTER(myThid)\n')
        f.write('      _BARRIER\n')
        f.write('\n')
        f.write('#endif /* ALLOW_GUD */\n')
        f.write('\n')
        f.write('      RETURN\n')
        f.write('      END\n')

sys.stderr.write(readername + '\n')
with open(readername, 'w') as f:
    dr,name = os.path.split(readername)
    base,ext = os.path.splitext(name)
    f.write('C$Header$\n')
    f.write('C$Name$\n')
    f.write('\n')
    f.write('C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n')
    f.write('C!!!!!!!!!!!!!! AUTOGENERATED FILE -- WILL BE OVERWRITTEN !!!!!!!!!!!!!!\n')
    f.write('C!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n')
    f.write('\n')
    f.write('#include "GUD_OPTIONS.h"\n')
    f.write('\n')
    f.write('      SUBROUTINE {0}(iUnit,oUnit,myThid)\n'.format(base.upper()))
    f.write('      IMPLICIT NONE\n')
    comments = []
    for code in codes['']:
        if code.lstrip().startswith('!') or len(code) == 0:
            comments.append(code + '\n')
        else:
            for comment in comments:
                f.write(comment)
            comments = []
            f.write(code + '\n')

    f.write('#include "{0}"\n'.format(headername))
    f.write('\n')
    f.write('      CHARACTER*(MAX_LEN_MBUF) msgBuf\n')
    f.write('      INTEGER iUnit,oUnit,myThid\n')
    f.write('\n')
    f.write('#ifdef ALLOW_GUD\n')
    f.write('\n')

    for secname, sec in secs.items():
        if secname in ['locals_read']:
            writedecls(f, sec)
            f.write('\n')

    for secname, sec in secs.items():
        if secname not in ['parameters', 'locals', 'locals_read']:
            vrs = [ name for lname,(name,tp,args,dim,rhs) in sec.items()]
            if len(vrs):
                f.write(''.join(heads[secname]))
                f.write(',\n     &    '.join(['      NAMELIST/{0}/\n     &    {1}'.format(secname, vrs[0])] +
                                       vrs[1:]) + '\n')
                f.write(''.join(foots[secname]))
                f.write('\n')

    if initname is None:
        for secname, sec in secs.items():
            if secname in ['locals']:
                writedecls(f, sec)
                f.write('\n')

    for comment in comments:
        f.write(comment)

    for secname, sec in secs.items():
        pad = 0
        writecode = (initname is None and secname not in ['parameters']
                    ) or secname in ['dependent']
        readnml = secname not in ['parameters', 'locals', 'locals_read', 'dependent']
        if writecode or readnml:
            f.write('C     {0}\n'.format(secname))
    #        for lname,(name,tp,args,dim,rhs) in sec.items():
    #            rhs = fltre.sub(r'\1 _d 0', rhs)
    #            rhs = expre.sub(r'\1 _d \2', rhs)
    #            f.write('      {0}{1}= {2},\n'.format(name, args, rhs))
    #        f.write('\n')
            while len(codes[secname]) and len(codes[secname][-1]) == 0:
                pad += 1
                codes[secname][-1:] = []

            for iline,line in enumerate(codes[secname]):
                line = line.rstrip()
                if '!' in line:
                    ind = line.index('!')
                    comment = line[ind:]
                    line = line[:ind]
                else:
                    comment = ''
                line = fltre.sub(r'\1 _d 0', line)
                line = expre.sub(r'\1 _d \2', line)
                try:
                    indent = line.index('=') + 2
                except ValueError:
                    indent = 2
                if line in ['/', '&'] and readnml:
                    f.write('      READ(UNIT=iUnit, NML={0})\n'.format(secname))
                elif line.lstrip().startswith('#'):
                    f.write(line + comment + '\n')
                elif writecode:
                    if len(line) == 0:
                        f.write(comment + '\n')
                    else:
                        pre = '      '
                        mx = 72
                        while len(line) > mx-len(pre):
                            i = min(mx-len(pre), len(line)) - 1
                            while i and line[i] in string.ascii_letters + string.digits + '_':
                                i -= 1
                            f.write('{0}{1}\n'.format(pre, line[:i+1].rstrip()))
                            line = line[i+1:]
                            pre = '     &' + indent*' '
                        line = line + comment
                        f.write('{0}{1}\n'.format(len(line) and pre or '', line))

            if readnml and not writecode:
                f.write('\n')

        f.write(max(0,pad-1)*'\n')

    f.write('\n')
    f.write('CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC\n')
    f.write('C     log all parameters to a namelist file\n')
    f.write('      IF ( oUnit .GE. 0 ) THEN\n')
    for secname, sec in secs.items():
        if len(sec) and secname not in ['locals', 'locals_read', 'parameters']:
            if heads[secname]:
                f.write(''.join(heads[secname]))
            f.write('       WRITE(UNIT=oUnit, NML={0})\n'.format(secname))
            if foots[secname]:
                f.write(''.join(foots[secname]))
    f.write('      ENDIF\n')

    f.write('\n')
    f.write('#endif /* ALLOW_GUD */\n')
    f.write('\n')
    f.write('      RETURN\n')
    f.write('      END\n')
